# This file is generated by scripts/generate_opcode_metadata.py
# for RustPython bytecode format.
# Do not edit!

# RustPython uses its own bytecode format with sequential opcode numbers.
# This file maps RustPython instruction names to their indices in the Instruction enum.

_specializations = {}

_specialized_opmap = {}

opmap = {
    'BEFORE_ASYNC_WITH': 0,
    'BEFORE_WITH': 1,
    'BINARY_OP': 2,
    'BINARY_SUBSCR': 3,
    'BREAK': 4,
    'BUILD_LIST_FROM_TUPLES': 5,
    'BUILD_LIST': 6,
    'BUILD_MAP_FOR_CALL': 7,
    'BUILD_MAP': 8,
    'BUILD_SET_FROM_TUPLES': 9,
    'BUILD_SET': 10,
    'BUILD_SLICE': 11,
    'BUILD_STRING': 12,
    'BUILD_TUPLE_FROM_ITER': 13,
    'BUILD_TUPLE_FROM_TUPLES': 14,
    'BUILD_TUPLE': 15,
    'CALL_FUNCTION_EX': 16,
    'CALL_KW': 17,
    'CALL': 18,
    'CALL_INTRINSIC_1': 19,
    'CALL_INTRINSIC_2': 20,
    'CALL_METHOD_EX': 21,
    'CALL_METHOD_KW': 22,
    'CALL_METHOD': 23,
    'CHECK_EG_MATCH': 24,
    'COMPARE_OP': 25,
    'CONTAINS_OP': 26,
    'CONTINUE': 27,
    'CONVERT_VALUE': 28,
    'COPY': 29,
    'DELETE_ATTR': 30,
    'DELETE_DEREF': 31,
    'DELETE_FAST': 32,
    'DELETE_GLOBAL': 33,
    'DELETE_NAME': 34,
    'DELETE_SUBSCR': 35,
    'DICT_UPDATE': 36,
    'END_ASYNC_FOR': 37,
    'END_FINALLY': 38,
    'ENTER_FINALLY': 39,
    'EXTENDED_ARG': 40,
    'FOR_ITER': 41,
    'FORMAT_SIMPLE': 42,
    'FORMAT_WITH_SPEC': 43,
    'GET_AITER': 44,
    'GET_ANEXT': 45,
    'GET_AWAITABLE': 46,
    'GET_ITER': 47,
    'GET_LEN': 48,
    'IMPORT_FROM': 49,
    'IMPORT_NAME': 50,
    'IS_OP': 51,
    'JUMP_IF_FALSE_OR_POP': 52,
    'JUMP_IF_NOT_EXC_MATCH': 53,
    'JUMP_IF_TRUE_OR_POP': 54,
    'JUMP': 55,
    'LIST_APPEND': 56,
    'LOAD_ATTR': 57,
    'LOAD_BUILD_CLASS': 58,
    'LOAD_CLASSDEREF': 59,
    'LOAD_CLOSURE': 60,
    'LOAD_CONST': 61,
    'LOAD_DEREF': 62,
    'LOAD_FAST': 63,
    'LOAD_FAST_AND_CLEAR': 64,
    'LOAD_GLOBAL': 65,
    'LOAD_METHOD': 66,
    'LOAD_NAME': 67,
    'MAKE_FUNCTION': 68,
    'MAP_ADD': 69,
    'MATCH_CLASS': 70,
    'MATCH_KEYS': 71,
    'MATCH_MAPPING': 72,
    'MATCH_SEQUENCE': 73,
    'NOP': 74,
    'POP_BLOCK': 75,
    'POP_EXCEPT': 76,
    'POP_JUMP_IF_FALSE': 77,
    'POP_JUMP_IF_TRUE': 78,
    'POP_TOP': 79,
    'RAISE_VARARGS': 80,
    'RESUME': 81,
    'RETURN_CONST': 82,
    'RETURN_VALUE': 83,
    'REVERSE': 84,
    'SET_ADD': 85,
    'SET_FUNCTION_ATTRIBUTE': 86,
    'SETUP_ANNOTATIONS': 87,
    'SETUP_EXCEPT': 88,
    'SETUP_FINALLY': 89,
    'SETUP_LOOP': 90,
    'STORE_ATTR': 91,
    'STORE_DEREF': 92,
    'STORE_FAST': 93,
    'STORE_FAST_LOAD_FAST': 94,
    'STORE_GLOBAL': 95,
    'STORE_NAME': 96,
    'STORE_SUBSCR': 97,
    'SUBSCRIPT': 98,
    'SWAP': 99,
    'TO_BOOL': 100,
    'UNARY_OP': 101,
    'UNPACK_EX': 102,
    'UNPACK_SEQUENCE': 103,
    'WITH_EXCEPT_START': 104,
    'YIELD_FROM': 105,
    'YIELD_VALUE': 106,
    'SEND': 107,
    'END_SEND': 108,
    'CLEANUP_THROW': 109,
    'SET_EXC_INFO': 110,
    'PUSH_EXC_INFO': 111,
    'CHECK_EXC_MATCH': 112,
    'RERAISE': 113,
    'CACHE': 256,
    'ENTER_EXECUTOR': 257,
    'JUMP_BACKWARD': 258,
    'JUMP_BACKWARD_NO_INTERRUPT': 259,
    'LOAD_SUPER_ATTR': 260,
    'LOAD_FAST_LOAD_FAST': 261,
    'STORE_FAST_STORE_FAST': 262,
    'JUMP_FORWARD': 263,
    'END_FOR': 264,
    'INTERPRETER_EXIT': 265,
    'LOAD_ASSERTION_ERROR': 266,
    'LOAD_LOCALS': 267,
    'BINARY_SLICE': 268,
    'STORE_SLICE': 269,
    'PUSH_NULL': 270,
    'RETURN_GENERATOR': 271,
    'GET_YIELD_FROM_ITER': 272,
    'COPY_FREE_VARS': 273,
    'LOAD_FAST_CHECK': 274,
    'LOAD_FROM_DICT_OR_DEREF': 275,
    'LOAD_FROM_DICT_OR_GLOBALS': 276,
    'DICT_MERGE': 277,
    'LIST_EXTEND': 278,
    'SET_UPDATE': 279,
    'MAKE_CELL': 280,
    'EXIT_INIT_CHECK': 281,
    'POP_JUMP_IF_NONE': 282,
    'POP_JUMP_IF_NOT_NONE': 283,
    'STORE_FAST_MAYBE_NULL': 284,
    'SETUP_CLEANUP': 285,
    'SETUP_WITH': 286,
    'JUMP_NO_INTERRUPT': 287,
    'UNARY_NEGATIVE': 288,
    'UNARY_INVERT': 289,
    'UNARY_NOT': 290,
    'BUILD_CONST_KEY_MAP': 291,
    'RESERVED': 292,
}

# FIXME:
# HAVE_ARGUMENT threshold is not used in RustPython's bytecode format.
# Unlike CPython where opcodes < HAVE_ARGUMENT have no arg,
# RustPython's Instruction enum explicitly defines which variants have arguments.
HAVE_ARGUMENT = 0
MIN_INSTRUMENTED_OPCODE = 256
